---
title: 'Devoir Méthodes bayésiennes : session 1'
author: "Benoit Gachet, Guillaume Mulier"
date: "`r format(Sys.Date(), '%d/%m/%Y')`"
output: 
  word_document: 
    toc: yes
    toc_depth : 2
    highlight: tango
    reference_docx: "template_word.docx"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(R2jags)
library(lattice)
library(ggmcmc)
library(ggtext)

theme_set(theme_light() +
            theme(plot.title = element_markdown(),
                  strip.background = element_blank(),
                  strip.text = element_textbox(
                    size = 12, 
                    color = "white", fill = "#7888C0", box.color = "#000066",
                    halign = 0.5, linetype = 1, r = unit(3, "pt"), width = unit(0.75, "npc"),
                    padding = margin(2, 0, 1, 0), margin = margin(3, 3, 3, 3))))
```

# Les données

```{r}
sncf_machines <- tibble(
  machine = 1:10,
  anciennete = c(2, 14, 2, 9, 15, 7, 3, 14, 5, 2),
  nb_pannes = c(3, 50, 7, 20, 44, 3, 1, 58, 8, 7)
)
```

# Modèle 1

Le modèle est le suivant :
$$
\begin{array}{l}
y_i\sim\mathcal{P}ois(\lambda)\\
avec\left\{\begin{array}{l}
y_i\quad le\quad nombre\quad de\quad pannes\quad de\quad la\quad machine\quad i\\
log(\lambda)=a
\end{array}\right.
\end{array}
$$
On a $log(\lambda)=a \Leftrightarrow \lambda=e^a$.
## Question 1

$$
\begin{array}{ll}
E(y_i|a) &= E(\mathcal{P}ois(\lambda))\\
&= \lambda\\
&= e^a
\end{array}
$$

## Question 2

Réalisation du modèle avec JAGS :
```{r, warning = FALSE, message = FALSE, result = 'hide'}
# Données à présenter sous forme d'une liste
donnees <- as.list(sncf_machines)
# Modèle dans langage BUGS et pas en langage R
modele_1 <- function() {
  # Modèle pour yi
  for (i in 1:10) {
    nb_pannes[i] ~ dpois(exp(a))
  }
  # Loi a priori de a
  a ~ dnorm(0, 0.001)
}
# Paramètres à recueillir
parametres_modele1 <- c("a")
# Valeurs initiales
inits_1 <- list("a" = 0)
inits_modele1 <- list(inits_1)
n_iter <- 50000  # Nombre d'iterations 
n_burn <- 1000 # Burn in

# Faire tourner le modèle avec la fonction jags
# D'abord sans thin, ni burn in
modele1_fit <- jags(data = donnees,
                    inits = inits_modele1,
                    parameters.to.save = parametres_modele1, 
                    n.chains = length(inits_modele1),
                    n.iter = n_iter, 
                    n.burnin = 0, 
                    n.thin = 1,
                    model.file = modele_1) 
modele1_fit_mcmc <- as.mcmc(modele1_fit)
```

On regarde si le paramètre a estimé a bien convergé.

```{r, fig.width = 10, fig.height = 7}
gg_modele1 <- ggs(modele1_fit_mcmc)
ggplot(gg_modele1 %>% filter(Parameter == "a"), aes(x = Iteration, y = value)) +
  geom_line() +
  geom_vline(xintercept = 1000, color = "purple", linetype = "dotted") +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC",
       subtitle = "Initialisation de a à 0")
```

On voit que la valeur du paramètre *a* reste autour de la valeur 3 et n'a pas l'air de s'écarter beaucoup de cette valeur. Nous vérifierons par la suite si cette convergence est conservée en augmentant le nombre de chaînes. Nous allons ensuite vérifier si les valeurs des paramètres estimés  

```{r}
ggs_autocorrelation(gg_modele1)
```

On voit que pour l'estimation de a, il y a corrélation jusqu'à la 3ème mesure. Pour la déviance, en revanche, cela va jusquà 8. Nous allons donc prendre une estimation sur 8 pour essayer de casser cette autocorrélation.

```{r, warning = FALSE, message = FALSE, result = 'hide'}
n_thin <-  8
# Faire tourner le modèle avec la fonction jags
# D'abord sans thin, ni burn in
modele1_fit_thin <- jags(data = donnees,
                         inits = inits_modele1,
                         parameters.to.save = parametres_modele1, 
                         n.chains = length(inits_modele1),
                         n.iter = n_iter * n_thin, 
                         n.burnin = n_burn, 
                         n.thin = n_thin,
                         model.file = modele_1) 
modele1_fit_thin_mcmc <- as.mcmc(modele1_fit_thin)
```

```{r, fig.width = 10, fig.height = 7}
gg_modele1_thin <- ggs(modele1_fit_thin_mcmc)
ggplot(gg_modele1_thin %>% filter(Parameter == "a"), aes(x = Iteration, y = value)) +
  geom_line() +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC",
       subtitle = "Initialisation de a à 0 ; Prise d'une valeur sur 8")
```

En ne prenant qu'une observation sur 8, on voit que le traceplot reste similaire avec une bonne convergence de l'estimation de a autour de 3 après le retrait de 1000 observations de burn in.

```{r}
ggs_autocorrelation(gg_modele1_thin)
```

Sur le graphique d'auto-corrélations, on voit que le problème de mélangeance a été réglé et que maintenant il n'y a plus d'auto-corrélation pour le paramètre a estimer.

Afin de nous assurer de la convergence du modèle, nous avons réalisé 3 chaînes avec des départ pour des valeurs différentes. Nous avons initié a à -5, 0 et 5 et regardé comment se comportait le modèle.

```{r}
inits_2 <- list("a" = 5)
inits_3 <- list("a" = -5)
inits_modele1_mult <- list(inits_1, inits_2, inits_3)
modele1_fit_mult <- jags(data = donnees,
                         inits = inits_modele1_mult,
                         parameters.to.save = parametres_modele1, 
                         n.chains = length(inits_modele1_mult),
                         n.iter = n_iter * n_thin, 
                         n.burnin = n_burn, 
                         n.thin = n_thin,
                         model.file = modele_1) 
modele1_fit_mult_mcmc <- as.mcmc(modele1_fit_mult)
gg_modele1_mult <- ggs(modele1_fit_mult_mcmc)
```

```{r}
ggs_autocorrelation(gg_modele1_mult) +
  facet_grid(Chain ~ Parameter)
```

```{r}
ggplot(gg_modele1_mult %>% filter(Parameter == "a"), aes(x = Iteration, y = value)) +
  geom_line(aes(color = as.factor(Chain)), alpha = 0.3) +
  geom_vline(xintercept = 1000, color = "purple", linetype = "dotted") +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC avec 3 chaînes") +
  theme(legend.position = "none")
```









# Modèle 2 

## Question 1 : 
Donner $E(yi|a0,b0,xi)$ d'après ce modèle en fonction de a0, b0 et de xi ? Si b0=0, que cela signifie-t-il ? Même question si b0 est supérieur à 0 ou si b0 est inférieur à 0 ? 

Si b = 0 cela signifie que nous sommes dans le modèle 1 avec $E(y_i|a) = e^a$ et que le nombre de panne ne dépend pas du temps.
Si b est supérieur ou inférieur à 0 cela que $E(y_i|a) = e^{a+bx}$ et que le nombre de panne augmente avec le vieilliesment de la machine si B > 0 et diminue si B < 0

## Question 2 :
Mettre en place ce modèle avec, comme loi a priori sur a0 et b0 , une loi normale d'espérance nulle et de variance 1000. Faire 30000 itérations et enlever 1000 itérations pour le temps de chauffe. D'après l'history et les autocorrélations, voyez-vous un problème de mélangeance de l'algorithme ? Si oui, mettre un thin à 10. Cela a-t-il amélioré la mélangeance ? On considèrera que c'est suffisant. 

```{r}
modele_2 <- function(){
  for (i in 1:length(nb_pannes)) {
    nb_pannes[i]~dpois(lam[i])
    log(lam[i]) = a+b0*anciennete[i]
  }
  a ~ dnorm(0,1.0E-3) 
  b0 ~ dnorm(0,1.0E-3) 
}

# paramètres
parametres_modele2 <- c("a","b0")

# Inits
inits2<- list("a"=3, "b0"= 1)
inits_modele2<-list(inits2)

#nbre d'iterations

n_burn2 = 1000 # burn-in
n_iter2 = 30000 #nbre total d'iterations
n_thin2 = 1 #thin

modele2_fit <-jags(
  data = donnees,
  inits = inits_modele2,
  parameters.to.save = parametres_modele2,
  n.chains = 1,
  n.iter = n_iter2,
  n.burnin = n_burn2,
  n.thin =n_thin2,
  model.file = modele_2)
modele2_fit_mcmc <- as.mcmc(modele2_fit)

```

On regarde si le paramètre a estimé a bien convergé.

```{r, fig.width = 10, fig.height = 7}
gg_modele2_a <- ggs(modele2_fit_mcmc)
ggplot(gg_modele2 %>% filter(Parameter == "a"), aes(x = Iteration, y = value)) +
  geom_line() +
  geom_vline(xintercept = 1000, color = "purple", linetype = "dotted") +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC",
       subtitle = "Initialisation de a à 0")

gg_modele2_b <- ggs(modele2_fit_mcmc)
ggplot(gg_modele2 %>% filter(Parameter == "b0"), aes(x = Iteration, y = value)) +
  geom_line() +
  geom_vline(xintercept = 1000, color = "purple", linetype = "dotted") +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC",
       subtitle = "Initialisation de a à 0")
```
On voit que les valeurs des paramètres *a* *b0* restent respectivement autour de la valeur 1 et 0.2 *b0* et n'ont pas l'air de s'écarter beaucoup de cette valeur. Nous vérifierons par la suite si cette convergence est conservée en augmentant le nombre de chaînes. Nous allons ensuite vérifier si les valeurs des paramètres estimés n'ont pas d'auto-corrélation.

```{r}
ggs_autocorrelation(gg_modele2_a)

```

On voit que pour l'estimation de a et b0, il y a corrélation jusqu'à la 20ème mesure. Pour la déviance, en revanche, cela va jusquà 10. Nous allons donc prendre une estimation sur 10 pour essayer de casser cette autocorrélation en augmentant le nombre d'intération de 10 fois pour ne pas perdre le nombre d'itérations effectives.

```{r, warning = FALSE, message = FALSE, result = 'hide'}
n_thin2.1 <-  10
modele2_fit_thin <- jags(data = donnees,
                         inits = inits_modele2,
                         parameters.to.save = parametres_modele2, 
                         n.chains = length(inits_modele2),
                         n.iter = n_iter2 * n_thin2.1, 
                         n.burnin = n_burn2, 
                         n.thin = n_thin2.1,
                         model.file = modele_2) 
modele2_fit_thin_mcmc <- as.mcmc(modele2_fit_thin)
```

```{r, fig.width = 10, fig.height = 7}
gg_modele2_thin <- ggs(modele2_fit_thin_mcmc)
ggplot(gg_modele2_thin %>% filter(Parameter == "a"), aes(x = Iteration, y = value)) +
  geom_line() +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC",
       subtitle = "Initialisation de a à 0 ; Prise d'une valeur sur 8")

ggplot(gg_modele2_thin %>% filter(Parameter == "b0"), aes(x = Iteration, y = value)) +
  geom_line() +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC",
       subtitle = "Initialisation de a à 0 ; Prise d'une valeur sur 8")
```

En ne prenant qu'une observation sur 10, on voit que le traceplot reste similaire avec une bonne convergence de l'estimation de a autour des même valeurs après le retrait de 1000 observations de burn in.

```{r}
ggs_autocorrelation(gg_modele2_thin)
```

Sur le graphique d'auto-corrélations, on voit que le problème de mélangeance a été réglé et que maintenant il n'y a plus d'auto-corrélation pour les paramètre a estimer.

Afin de nous assurer de la convergence du modèle, nous avons réalisé 3 chaînes avec des départ pour des valeurs différentes. Nous avons initié *a* à -5, -3 et 0, *b0* a 5, -5 et 0 et regardé comment se comportait le modèle.

```{r}
inits_2.1 <- list("a"=5, "b0"=5)
inits_2.2 <- list("a"=-3, "b0"=-5)
inits_2.3 <- list("a"=0, "b0"=0)

inits_modele2_mult <- list(inits_2.1, inits_2.2, inits_2.3)
modele2_fit_mult <- jags(data = donnees,
                         inits = inits_modele2_mult,
                         parameters.to.save = parametres_modele2, 
                         n.chains = length(inits_modele1_mult),
                         n.iter = n_iter2 * n_thin2.1, 
                         n.burnin = n_burn2, 
                         n.thin = n_thin2.1,
                         model.file = modele_2) 
modele2_fit_mult_mcmc <- as.mcmc(modele2_fit_mult)
gg_modele2_mult <- ggs(modele2_fit_mult_mcmc)
```

```{r}
ggs_autocorrelation(gg_modele2_mult) +
  facet_grid(Chain ~ Parameter)
```

```{r}
ggplot(gg_modele2_mult %>% filter(Parameter == "a"), aes(x = Iteration, y = value)) +
  geom_line(aes(color = as.factor(Chain)), alpha = 0.3) +
  geom_vline(xintercept = 1000, color = "purple", linetype = "dotted") +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC avec 3 chaînes") +
  theme(legend.position = "none")

ggplot(gg_modele2_mult %>% filter(Parameter == "b0"), aes(x = Iteration, y = value)) +
  geom_line(aes(color = as.factor(Chain)), alpha = 0.3) +
  geom_vline(xintercept = 1000, color = "purple", linetype = "dotted") +
  scale_x_continuous(labels = scales::comma_format()) +
  labs(x = "Itération",
       y = "a",
       title = "Traceplot de l'estimation de a par MCMC avec 3 chaînes") +
  theme(legend.position = "none")
```


## Question 3 :
Que vaut le nombre d’itérations pour les calculs ? Que vaut le nombre d’itérations « effectif » ?

Le nombre d'itérations pour notre calcul est de 300 000 mais nous avons mis un thin de 10, le nombre d'itéartions effectif est de 26551.18 pour le paramètre *a* et de 27173.10 pour le paramètre *b0*. Cela représente le nombre d'itérations qui ont apportées de l'information utile à notre modèle.


```{r}
print(modele2_fit_thin)
effectiveSize(modele2_fit_thin)

```

## Question 4 :
Si ce n’est pas le cas, refaire tourner votre modèle pour que le nombre effectif d’itérations soit au moins de 10000.

Nous avions anticipé la diminution du nombre d'itérations "effectif" avec l'augmentationn du thin. Nous sommes donc au supérieur à 10 000 itération effectives. Cependant pour atteindre ce chiffre nous pouvons diminuer notre nombre total d'itéartions. Le nombre d'itération nécessaire pour atteindre 10 000 itération effectives avoisine 120 000.

```{r}
modele2_fit_thinopti <- jags(data = donnees,
                         inits = inits_modele2,
                         parameters.to.save = parametres_modele2, 
                         n.chains = length(inits_modele2),
                         n.iter = 120000, 
                         n.burnin = n_burn2, 
                         n.thin = n_thin2.1,
                         model.file = modele_2) 
effectiveSize(modele2_fit_thinopti)

```


## Question 5 : 
Donnez la moyenne a posteriori et l'intervalle de crédibilité à 95% de a0 et b0.

La moyenne de a0 est de 0.94, son intervalle de crédibilité à 95% est de [0.48-1.37]
La moyenne de b0 est de 0.21, son intervalle de crédibilité à 95% est de [0.17-1.24]


````{r}

res = summary(modele2_fit_thin_mcmc)
resmoy = as.data.frame(res[[1]])
resq = as.data.frame(res[[2]])


a_2.5 = resq$'2.5%'[1]
a_97.5 = resq$'97.5%'[1]

b0_2.5 = resq$'2.5%'[2]
b0_97.5 = resq$'97.5%'[2]


lambda = exp(resmoy$Mean[1] + resmoy$Mean[2]*t)
lambdainf = exp(aaq2.5)

aaq97.5 = resq$'97.5%'[1]
thetasup = exp(aaq97.5)
````

Nous avons également représenté le densityplot de chaque variable

```{r}
densityplot(modele2_fit_thin_mcmc[,1:2], layout=c(2,1), aspect = "fill")
```